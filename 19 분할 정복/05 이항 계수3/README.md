## 문제

자연수 N과 정수 K가 주어졌을 때 이항 계수 (N)C(K)를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.


### 입력

첫째 줄에 N과 K가 주어진다. (1 ≤  N≤ 4,000,000, 0 ≤ K ≤ N)


### 출력

(N)C(K)를 1,000,000,007로 나눈 나머지를 출력한다.


---

이항 계수를 구하기 위해 N!/(K! * (N-K)!) 을 계산해야 한다.

하지만 입력값의 팩토리얼 연산 진행시 오버플로우가 발생한다.

따라서 모듈러의 곱에 대한 성질을 이용하여 중간중간 모듈러 연산을 진행해주어 연산값을 낮춘다.


모듈러의 곱 : (a*b) mod c = ((a mod c) * (b mod c)) mod c

하지만 이항 계수 연산과정에서 해야하는 나눗셈의 경우 모듈러의 성질이 적용되지 않는다.

따라서 나눗셈의 경우 해당 모듈러 연산의 역원을 구하여 곱의 형식으로 바꿔준다.

즉,  (K! * (N - K)!) 의 모듈러 역원을 구한뒤 모듈러의 곱에 대한 정리를 활용한다.

여기서 (K! * (N - K)!)의 역원을 구하는 방식에 대한 효율적인 알고리즘이 필요하다.

    long long IEM(int n) {
        if (n == 1) {
        return 1;
    }
    long long ie = mod / n;
    while (true) {
        if ((n * ie) % mod == 1) {
            break;
        }
        ie++;
    }
    return ie;
    }

완전 탐색의 방법으로 moduler inverse을 구하려고 하였으나 값이 너무 커서 굉장히 비효율적이고 시간 소유가 많이 걸린다.

페르마의 소정리: 
"p가 소수이고 a가 p의 배수가 아니면 a^(p-1) = 1 (mod p) 이다. 즉, a^(p-1)을 p로 나눈 나머지는 1이다."

를 이용하여 역원을 효율적으로 구하는 방법을 취해야 한다.

B^(p-1) = 1 (mod p)
B * B^(p-1) = 1 (mod p)
B^(p-2) = B^-1 (mod P)

따라서 해당 B^(p-2)와 모듈러의 곱의 정리를 이용하면

AB^(-1)%p = AB^(p-2)%p = (A%P)(B^(p-2)%p)%p

형식으로 정리할 수 있다.


